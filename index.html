<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê·ªìng H·ªì Web - M·ª•c ti√™u Gi·ªù v√† Th·ªùi l∆∞·ª£ng</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400..700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Body Styles */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #1e223a;
            font-family: 'Roboto', sans-serif;
            color: #e0e0e0;
            overflow-y: auto;
            padding: 40px 15px;
        }

        /* Main Container */
        .clock-container {
            width: 100%;
            max-width: 700px;
            text-align: center;
            position: relative;
            background-color: rgba(40, 45, 70, 0.7);
            padding: 60px 5% 40px 5%;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Top Controls */
        .top-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            gap: 10px;
            z-index: 10;
        }
        .top-controls button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8rem;
            font-weight: 500;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
        }
        .top-controls button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .top-controls button:active:not(:disabled) { transform: scale(0.95); }
        .top-controls button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(80%); }
        #wake-lock-btn.active { background-color: #f0a500; color: #111; border-color: #f0a500; font-weight: bold; }

        /* Message Area */
        .message-area {
            min-height: 1.5em;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-weight: 500;
            text-align: center;
            transition: opacity 0.3s ease;
        }
        .message-area.error { color: #d9534f; }
        .message-area.success { color: #5cb85c; }
        .message-area.info { color: #5bc0de; }
        .message-area.warning { color: #f0ad4e; }
        .message-area:empty { opacity: 0; }

        /* Digital Clock Display */
        .digital-clock {
            font-weight: 500;
            margin-bottom: 5px;
            letter-spacing: 1px;
            display: flex;
            justify-content: center;
            align-items: baseline;
            flex-wrap: wrap;
            color: #66fcf1;
            text-shadow: 0 0 10px rgba(102, 252, 241, 0.3);
        }
        #hours, #minutes, #seconds, .colon, .ampm {
            font-family: 'Roboto Mono', monospace;
            display: inline-block;
            line-height: 1;
        }
        #hours, #minutes, #seconds { font-size: clamp(3.5rem, 16vw, 6.5rem); }
        .colon { font-size: clamp(3rem, 14vw, 5.5rem); margin: 0 clamp(-2px, 0.5vw, 3px); opacity: 0.85; }
        .ampm {
            font-family: 'Roboto', sans-serif;
            font-size: clamp(1.3rem, 5vw, 2rem);
            font-weight: 500;
            color: #66fcf1;
            margin-left: clamp(5px, 1.5vw, 10px);
            text-transform: uppercase;
            opacity: 0.9;
            align-self: flex-end;
            padding-bottom: calc(clamp(3.5rem, 16vw, 6.5rem) * 0.1);
        }

        /* Date Display */
        .date-display {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            margin-top: 0;
            margin-bottom: 35px;
            color: #bdc3c7;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Target Section */
        .target-section {
            margin-bottom: 35px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        #target-controls-wrapper {
             transition: opacity 0.3s ease, max-height 0.3s ease;
             overflow: hidden;
        }
        #target-controls-wrapper.hidden {
             opacity: 0;
             max-height: 0;
             margin-bottom: 0;
             pointer-events: none;
        }
        .target-mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }
        .target-mode-selector label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ccc;
        }
        .target-mode-selector input[type="radio"] {
            cursor: pointer;
            accent-color: #66fcf1;
        }
        .target-input-group, .target-duration-group {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
         .target-input-group.hidden, .target-duration-group.hidden {
             display: none !important;
        }
        .target-input-group label, .target-duration-group label {
            font-size: 0.95rem;
            color: #ccc;
            white-space: nowrap;
        }
        .target-input-group input[type="date"],
        .target-input-group input[type="time"],
        .target-duration-group input[type="number"] {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #eee;
            padding: 9px 12px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            height: 40px;
            box-sizing: border-box;
        }
        .target-input-group input[type="date"] { min-width: 140px; }
        .target-input-group input[type="time"] { min-width: 115px; }
        .target-duration-group input[type="number"] { min-width: 100px; text-align: right; }
        .target-input-group input[type="date"]::-webkit-calendar-picker-indicator,
        .target-input-group input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8);
            cursor: pointer;
        }
        #set-target-btn, #set-duration-target-btn {
            background-color: #5bc0de;
            color: #fff;
            border: none;
            padding: 0 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            height: 40px;
            box-sizing: border-box;
            line-height: 40px;
            margin-left: 5px;
        }
        #set-target-btn:hover:not(:disabled),
        #set-duration-target-btn:hover:not(:disabled) {
             filter: brightness(1.15);
        }
        #set-target-btn:active:not(:disabled),
        #set-duration-target-btn:active:not(:disabled) {
            transform: scale(0.96);
        }
        #set-target-btn:disabled,
        #set-duration-target-btn:disabled,
        .target-input-group input:disabled,
        .target-duration-group input:disabled {
            background-color: #777;
            cursor: not-allowed;
            opacity: 0.7;
        }
        #target-info {
            font-size: 0.95rem;
            color: #bbb;
            min-height: 1.2em;
            margin-bottom: 8px;
            font-style: italic;
        }
        #target-info span { font-weight: bold; color: #f0a500; font-style: normal; }
        #arrival-status {
            font-size: 0.95rem;
            font-weight: bold;
            min-height: 1.2em;
            margin-bottom: 15px;
            transition: color 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }
        #arrival-status:empty { opacity: 0; }
        #arrival-status.early { color: #5cb85c; }
        #arrival-status.late { color: #d9534f; }
        #arrival-status.on-time { color: #5bc0de; }
        #arrival-status.completed { color: #5cb85c; }
        #arrival-status.exceeded { color: #d9534f; }
        #arrival-status.running-late { color: #f0ad4e; font-style: italic; }
        .progress-bar-container {
            width: 100%;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            border-radius: 12px;
            transition: width 0.2s linear, background-color 0.3s ease;
            text-align: center;
            color: rgba(0, 0, 0, 0.8);
            font-size: 0.85rem;
            line-height: 24px;
            font-weight: bold;
            box-sizing: border-box;
            white-space: nowrap;
            background-color: #5cb85c;
        }

        /* Stopwatch Section */
        .stopwatch-section { margin-top: 0; padding-top: 0; }
        #stopwatch-display {
            font-family: 'Roboto Mono', monospace;
            font-size: clamp(2.2rem, 9vw, 3.5rem); /* Base size for HH:MM:SS */
            color: #f0a500;
            margin-bottom: 35px;
            letter-spacing: 1px;
            font-weight: 500;
            word-break: break-all;
            /* NEW: Use flex to align baseline of time and ms */
            display: inline-flex;
            align-items: baseline;
            gap: 2px; /* Small gap between seconds and ms */
        }
        /* NEW: Style for milliseconds */
        .stopwatch-ms {
            font-size: 0.6em; /* Smaller font size relative to parent */
            opacity: 0.85; /* Slightly less prominent */
            font-weight: 400; /* Lighter weight */
            /* Baseline alignment handled by parent flex */
        }

        .stopwatch-controls {
            margin-bottom: 35px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px 15px;
        }
        .stopwatch-controls button {
            border: none;
            color: #fff;
            padding: 12px 25px;
            margin: 0;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
            min-width: 120px;
        }
        .stopwatch-controls button#start-btn { background-color: #5cb85c; }
        .stopwatch-controls button#pause-btn { background-color: #f0ad4e; }
        .stopwatch-controls button#resume-btn { background-color: #5bc0de; }
        .stopwatch-controls button#stop-btn { background-color: #d9534f; }
        .stopwatch-controls button#reset-btn { background-color: #777; }
        .stopwatch-controls button#clear-history-btn {
            background-color: #6c757d;
            font-size: 0.9rem;
            min-width: auto;
            padding: 10px 20px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }
        .stopwatch-controls button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }
        .stopwatch-controls button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
        }
        .stopwatch-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
            box-shadow: none;
        }

        /* History Section */
        .history-section {
            margin-top: 45px;
            padding-top: 25px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }
        .history-section h3 {
            color: #ccc;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-align: left;
            font-weight: 500;
        }
        #travel-history-list {
            list-style: none;
            padding: 0;
            margin: 0;
            min-height: 150px;
            text-align: left;
            margin-bottom: 25px;
        }
        .history-entry {
            background-color: rgba(255, 255, 255, 0.04);
            border-radius: 8px;
            padding: 18px;
            margin-bottom: 15px;
            border-left: 5px solid #f0a500;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .history-entry:hover { background-color: rgba(255, 255, 255, 0.08); }
        .history-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            flex-wrap: wrap;
            gap: 5px 15px;
        }
        .history-group { display: flex; align-items: baseline; gap: 6px; }
        .history-label { color: #bbb; font-weight: 500; min-width: 70px; text-align: left; }
        .history-value { font-family: 'Roboto Mono', monospace; color: #f0a500; font-weight: bold; text-align: left; }
        .history-value-alt { font-family: 'Roboto', sans-serif; font-size: 0.85em; color: #ccc; margin-left: 5px; }
        .history-status { margin-top: 8px; font-weight: bold; font-size: 0.9em; width: 100%; }
        .history-status.early, .history-status.completed { color: #5cb85c; }
        .history-status.late, .history-status.exceeded { color: #d9534f; }
        .history-status.on-time { color: #5bc0de; }
        .no-history-message {
            text-align: center; color: #888; padding: 30px 0; font-style: italic;
        }

        /* Pagination Controls */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .pagination-controls button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ccc;
            padding: 7px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.85rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
        }
        .pagination-controls button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.25);
        }
        .pagination-controls button:active:not(:disabled) { transform: scale(0.95); }
        .pagination-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        #page-info { font-size: 0.85rem; color: #aaa; white-space: nowrap; }

        /* Utility Classes */
        .hidden { display: none !important; }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            body { padding: 25px 10px; }
            .clock-container { padding: 50px 4% 30px 4%; }
            .top-controls { top: 15px; right: 15px; }
            #hours, #minutes, #seconds { font-size: clamp(3rem, 18vw, 5.5rem); }
            .colon { font-size: clamp(2.5rem, 16vw, 4.5rem); }
            .ampm { font-size: clamp(1.1rem, 6vw, 1.7rem); }
            .date-display { font-size: clamp(0.9rem, 4vw, 1.1rem); }
            .target-mode-selector { gap: 15px; margin-bottom: 15px;}
            .target-input-group, .target-duration-group { flex-direction: column; align-items: stretch; gap: 12px; }
            .target-input-group label, .target-duration-group label { text-align: center; }
            .target-input-group input[type="date"],
            .target-input-group input[type="time"],
            .target-duration-group input[type="number"],
            #set-target-btn, #set-duration-target-btn {
                 width: 100%; min-width: unset; margin-left: 0;
            }
            /* Adjust stopwatch display font size */
            #stopwatch-display { font-size: clamp(1.8rem, 10vw, 3rem); }
            .stopwatch-controls { gap: 10px; }
            .stopwatch-controls button { min-width: 100px; padding: 10px 20px; font-size: 0.9rem; }
            .history-entry { padding: 15px; }
            .history-row { flex-direction: column; align-items: flex-start; gap: 3px; }
            .history-group { width: 100%; justify-content: space-between; }
            .history-label { min-width: 60px; }
        }
        @media (max-width: 400px) {
            #hours, #minutes, #seconds { font-size: clamp(2.5rem, 20vw, 4.5rem); }
            .colon { font-size: clamp(2rem, 18vw, 3.5rem); }
            .ampm { font-size: clamp(1rem, 7vw, 1.5rem); }
             /* Adjust stopwatch display font size */
            #stopwatch-display { font-size: clamp(1.6rem, 12vw, 2.5rem); }
            .stopwatch-controls button { min-width: 90px; padding: 10px 15px; font-size: 0.85rem; }
            .pagination-controls button { padding: 6px 10px; font-size: 0.8rem;}
            #page-info { font-size: 0.8rem; }
        }

    </style>
</head>
<body>

<div class="clock-container">
    <div class="top-controls">
        <button id="wake-lock-btn" title="Gi·ªØ m√†n h√¨nh s√°ng (n·∫øu tr√¨nh duy·ªát h·ªó tr·ª£)">Gi·ªØ s√°ng</button>
        <button id="format-toggle-btn" title="ƒê·ªïi ƒë·ªãnh d·∫°ng 12/24 gi·ªù">24h</button>
    </div>

    <div id="message-area" class="message-area" aria-live="polite"></div>

    <div class="digital-clock">
        <span id="hours">00</span><span class="colon">:</span><span id="minutes">00</span><span class="colon">:</span><span id="seconds">00</span>
        <span id="ampm" class="ampm"></span>
    </div>
    <div class="date-display" id="date"></div>

    <div class="target-section">
        <div id="target-controls-wrapper">
            <div class="target-mode-selector">
                <label>
                    <input type="radio" name="target-mode" value="time" id="target-mode-time" checked>
                    Theo Th·ªùi ƒëi·ªÉm
                </label>
                <label>
                    <input type="radio" name="target-mode" value="duration" id="target-mode-duration">
                    Theo Th·ªùi l∆∞·ª£ng
                </label>
            </div>
            <div id="target-time-group" class="target-input-group">
                <label for="target-date">Ng√†y:</label>
                <input type="date" id="target-date" name="target-date">
                <label for="target-time">Gi·ªù:</label>
                <input type="time" id="target-time" name="target-time">
                <button id="set-target-btn">ƒê·∫∑t M·ª•c Ti√™u</button>
            </div>
            <div id="target-duration-group" class="target-duration-group hidden">
                <label for="target-duration-input">Th·ªùi l∆∞·ª£ng (ph√∫t):</label>
                <input type="number" id="target-duration-input" name="target-duration" min="1" step="1">
                <button id="set-duration-target-btn">ƒê·∫∑t M·ª•c Ti√™u</button>
            </div>
        </div>
        <div id="target-info" aria-live="polite">Ch∆∞a ƒë·∫∑t m·ª•c ti√™u</div>
        <div id="arrival-status" aria-live="polite"></div>
        <div class="progress-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div class="stopwatch-section">
        <div id="stopwatch-display" aria-live="polite">00:00:00<span class="stopwatch-ms">.000</span></div>
        <div class="stopwatch-controls">
            <button id="start-btn" disabled>B·∫Øt ƒë·∫ßu</button>
            <button id="pause-btn" class="hidden">T·∫°m d·ª´ng</button>
            <button id="resume-btn" class="hidden">Ti·∫øp t·ª•c</button>
            <button id="stop-btn" class="hidden">K·∫øt th√∫c</button>
            <button id="reset-btn" disabled>Reset</button>
            <button id="clear-history-btn">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <div class="history-section">
        <h3>L·ªãch s·ª≠ Di chuy·ªÉn / Ho√†n th√†nh</h3>
        <ul id="travel-history-list">
            <li class="no-history-message">Kh√¥ng c√≥ l·ªãch s·ª≠ n√†o ƒë∆∞·ª£c ghi l·∫°i.</li>
        </ul>
        <div class="pagination-controls">
            <button id="prev-page-btn" disabled>Tr∆∞·ªõc</button>
            <span id="page-info">Trang 1 / 1</span>
            <button id="next-page-btn" disabled>Sau</button>
        </div>
    </div>
</div>

<script>
    // === DOM Element References ===
    const hoursElement = document.getElementById('hours');
    const minutesElement = document.getElementById('minutes');
    const secondsElement = document.getElementById('seconds');
    const ampmElement = document.getElementById('ampm');
    const dateElement = document.getElementById('date');
    const formatToggleButton = document.getElementById('format-toggle-btn');
    const targetControlsWrapper = document.getElementById('target-controls-wrapper');
    const targetModeTimeRadio = document.getElementById('target-mode-time');
    const targetModeDurationRadio = document.getElementById('target-mode-duration');
    const targetTimeGroup = document.getElementById('target-time-group');
    const targetDurationGroup = document.getElementById('target-duration-group');
    const targetDateInput = document.getElementById('target-date');
    const targetTimeInput = document.getElementById('target-time');
    const targetDurationInput = document.getElementById('target-duration-input');
    const setTargetBtn = document.getElementById('set-target-btn');
    const setDurationTargetBtn = document.getElementById('set-duration-target-btn');
    const targetInfo = document.getElementById('target-info');
    const arrivalStatus = document.getElementById('arrival-status');
    const progressBarContainer = document.querySelector('.progress-bar-container');
    const progressBar = document.getElementById('progress-bar');
    const stopwatchDisplay = document.getElementById('stopwatch-display'); // Target this element
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const clearHistoryBtn = document.getElementById('clear-history-btn');
    const travelHistoryList = document.getElementById('travel-history-list');
    const prevPageBtn = document.getElementById('prev-page-btn');
    const nextPageBtn = document.getElementById('next-page-btn');
    const pageInfo = document.getElementById('page-info');
    const wakeLockBtn = document.getElementById('wake-lock-btn');
    const messageArea = document.getElementById('message-area');

    // === State Variables ===
    let is24HourFormat = false;
    let mainClockIntervalId = null;
    let stopwatchIntervalId = null;
    let stopwatchState = 'idle';
    let startTime = 0;
    let elapsedTime = 0;
    let stopwatchStartDate = null;
    let targetMode = 'time';
    let targetDateTime = null;
    let targetDurationMinutes = null;
    let estimatedDurationMs = 0;
    let projectedTargetDateTime = null;
    let travelHistory = [];
    let currentPage = 1;
    const itemsPerPage = 5;
    let wakeLock = null;
    let messageTimeoutId = null;

    // === LocalStorage Keys ===
    const HISTORY_STORAGE_KEY = 'travelClockHistory_v5';
    const FORMAT_STORAGE_KEY = 'clockFormatPreference';
    const TARGET_MODE_STORAGE_KEY = 'targetModePreference';

    // === Utility Functions ===
    function formatNumber(num) { return num < 10 ? '0' + num : num; }
    function formatTimeHHMMSS(date) { /* ... */
        if (!date || !(date instanceof Date) || isNaN(date)) return 'N/A';
        try {
            const hours = formatNumber(date.getHours());
            const minutes = formatNumber(date.getMinutes());
            const seconds = formatNumber(date.getSeconds());
            return `${hours}:${minutes}:${seconds}`;
        } catch (error) { console.error("Error formatting HHMMSS:", error, date); return 'L·ªói gi·ªù'; }
     }
    function formatDateYYYYMMDD(date) { /* ... */
        if (!date || !(date instanceof Date) || isNaN(date)) return '';
        try {
            const year = date.getFullYear();
            const month = formatNumber(date.getMonth() + 1);
            const day = formatNumber(date.getDate());
            return `${year}-${month}-${day}`;
        } catch (error) { console.error("Error formatting YYYYMMDD:", error, date); return ''; }
     }

    // --- MODIFIED: formatStopwatchTime now returns HTML string ---
    function formatStopwatchTime(timeMs) {
        if (typeof timeMs !== 'number' || isNaN(timeMs) || timeMs < 0) timeMs = 0;
        try {
            const totalSeconds = Math.floor(timeMs / 1000);
            const hours = formatNumber(Math.floor(totalSeconds / 3600));
            const minutes = formatNumber(Math.floor((totalSeconds % 3600) / 60));
            const seconds = formatNumber(totalSeconds % 60);
            const milliseconds = String(Math.floor(timeMs % 1000)).padStart(3, '0');
            // Return HTML with milliseconds wrapped in a span
            return `${hours}:${minutes}:${seconds}<span class="stopwatch-ms">.${milliseconds}</span>`;
        } catch (error) {
            console.error("Error formatting stopwatch time:", error, timeMs);
            // Return default HTML structure on error
            return '00:00:00<span class="stopwatch-ms">.000</span>';
        }
    }
    // --- END MODIFIED ---

    function formatDurationReadable(timeMs) { /* ... */
        if (typeof timeMs !== 'number' || isNaN(timeMs) || timeMs < 0) return 'N/A';
        try {
            const totalSeconds = Math.round(timeMs / 1000);
            if (totalSeconds < 60) return `${totalSeconds} gi√¢y`;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (seconds === 0) return `${minutes} ph√∫t`;
            return `${minutes} ph√∫t ${seconds} gi√¢y`;
        } catch (error) { console.error("Error formatting readable duration:", error, timeMs); return 'L·ªói th·ªùi gian'; }
     }
    function showMessage(text, type = 'info', duration = 3000) { /* ... */
        if (messageTimeoutId) clearTimeout(messageTimeoutId);
        messageArea.textContent = text;
        messageArea.className = `message-area ${type}`;
        messageArea.style.opacity = 1;
        if (duration > 0) { messageTimeoutId = setTimeout(() => { messageArea.style.opacity = 0; }, duration); }
     }
    function clearMessage() { /* ... */
        if (messageTimeoutId) clearTimeout(messageTimeoutId);
        messageArea.textContent = '';
        messageArea.className = 'message-area';
        messageArea.style.opacity = 0;
     }

    // === Main Clock Logic ===
    function updateClock() { /* ... */
        try {
            const now = new Date();
            let hours = now.getHours();
            const minutes = formatNumber(now.getMinutes());
            const secondsValue = formatNumber(now.getSeconds());
            let displayHours = hours;
            if (!is24HourFormat) {
                const ampm = hours >= 12 ? 'PM' : 'AM';
                displayHours = hours % 12; displayHours = displayHours ? displayHours : 12;
                ampmElement.textContent = ampm; ampmElement.classList.remove('hidden');
            } else { ampmElement.classList.add('hidden'); }
            hoursElement.textContent = formatNumber(displayHours);
            minutesElement.textContent = minutes; secondsElement.textContent = secondsValue;
            const day = formatNumber(now.getDate()); const month = formatNumber(now.getMonth() + 1);
            const year = now.getFullYear(); const dayOfWeek = now.toLocaleDateString('vi-VN', { weekday: 'long' });
            const dateString = `${dayOfWeek}, ${day}/${month}/${year}`; dateElement.textContent = dateString;
        } catch (error) { console.error("Error updating main clock:", error); }
     }

    // === Target Mode Logic ===
    function handleTargetModeChange() { /* ... */
        const newMode = document.querySelector('input[name="target-mode"]:checked').value;
        if (newMode !== targetMode) {
            targetMode = newMode; console.log("Target mode changed by user to:", targetMode);
            savePreferences(); showCorrectTargetGroup(); clearTargetState(); updateStopwatchUI('idle');
        }
     }
    function showCorrectTargetGroup() { /* ... */
         if (targetMode === 'time') {
            targetTimeGroup.classList.remove('hidden'); targetDurationGroup.classList.add('hidden');
        } else {
            targetTimeGroup.classList.add('hidden'); targetDurationGroup.classList.remove('hidden');
        }
     }
    function clearTargetState() { /* ... */
        targetDateTime = null; targetDurationMinutes = null; estimatedDurationMs = 0;
        projectedTargetDateTime = null; targetInfo.textContent = 'Ch∆∞a ƒë·∫∑t m·ª•c ti√™u';
        arrivalStatus.textContent = ''; arrivalStatus.className = '';
        progressBar.style.width = '0%'; progressBar.textContent = '';
        progressBarContainer.setAttribute('aria-valuenow', '0'); progressBar.style.backgroundColor = '#5cb85c';
     }

    // === Target Setting Logic ===
    function setTarget() { /* ... */
        clearMessage(); clearTargetState(); let isValidTarget = false;
        if (targetMode === 'time') {
            const dateValue = targetDateInput.value; const timeValue = targetTimeInput.value;
            if (!dateValue || !timeValue) { showMessage('Vui l√≤ng ch·ªçn c·∫£ ng√†y v√† gi·ªù m·ª•c ti√™u.', 'error'); return; }
            try {
                const dateTimeString = `${dateValue}T${timeValue}:00`; const potentialTargetDate = new Date(dateTimeString);
                if (isNaN(potentialTargetDate)) { showMessage('Ng√†y ho·∫∑c gi·ªù m·ª•c ti√™u kh√¥ng h·ª£p l·ªá.', 'error'); return; }
                const now = new Date(); if (potentialTargetDate <= now) { showMessage('Th·ªùi gian m·ª•c ti√™u ph·∫£i ·ªü trong t∆∞∆°ng lai.', 'warning', 5000); }
                targetDateTime = potentialTargetDate; projectedTargetDateTime = targetDateTime;
                const targetDateStr = targetDateTime.toLocaleDateString('vi-VN'); const targetTimeStr = formatTimeHHMMSS(targetDateTime);
                targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetTimeStr} (${targetDateStr})</span>`; isValidTarget = true;
            } catch (error) { console.error("Error setting target time:", error); showMessage("ƒê√£ x·∫£y ra l·ªói khi ƒë·∫∑t m·ª•c ti√™u th·ªùi gian.", 'error'); targetInfo.textContent = 'L·ªói ƒë·∫∑t m·ª•c ti√™u'; targetDateTime = null; }
        } else {
            const durationValue = parseInt(targetDurationInput.value, 10);
            if (isNaN(durationValue) || durationValue <= 0) { showMessage('Vui l√≤ng nh·∫≠p th·ªùi l∆∞·ª£ng m·ª•c ti√™u h·ª£p l·ªá (s·ªë ph√∫t > 0).', 'error'); targetDurationInput.focus(); return; }
            try {
                targetDurationMinutes = durationValue; targetDateTime = null; projectedTargetDateTime = null;
                targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetDurationMinutes} ph√∫t</span>`; isValidTarget = true;
            } catch (error) { console.error("Error setting target duration:", error); showMessage("ƒê√£ x·∫£y ra l·ªói khi ƒë·∫∑t m·ª•c ti√™u th·ªùi l∆∞·ª£ng.", 'error'); targetInfo.textContent = 'L·ªói ƒë·∫∑t m·ª•c ti√™u'; targetDurationMinutes = null; }
        }
        if (isValidTarget) {
            showMessage('ƒê√£ ƒë·∫∑t m·ª•c ti√™u th√†nh c√¥ng!', 'success');
            if (stopwatchState === 'running' || stopwatchState === 'paused') { resetStopwatch(false); }
            else { elapsedTime = 0; stopwatchDisplay.innerHTML = formatStopwatchTime(0); } // Use innerHTML
             updateStopwatchUI('idle');
        } else { updateStopwatchUI('idle'); }
        console.log("Target set - Mode:", targetMode, "DateTime:", targetDateTime, "DurationMins:", targetDurationMinutes);
     }

    // === Progress Bar Logic ===
    function updateProgressBar(currentTotalElapsedTime) { /* ... */
        if (!estimatedDurationMs || estimatedDurationMs <= 0) { progressBar.style.width = '0%'; progressBar.textContent = ''; progressBarContainer.setAttribute('aria-valuenow', '0'); return; }
        try {
            let progressPercent = (currentTotalElapsedTime / estimatedDurationMs) * 100; progressPercent = Math.max(0, Math.min(100, progressPercent));
            progressBar.style.width = progressPercent.toFixed(1) + '%'; progressBar.textContent = progressPercent.toFixed(0) + '%'; progressBarContainer.setAttribute('aria-valuenow', progressPercent.toFixed(0));
            if (progressPercent >= 90) { progressBar.style.backgroundColor = '#d9534f'; }
            else if (progressPercent >= 60) { progressBar.style.backgroundColor = '#f0ad4e'; }
            else { progressBar.style.backgroundColor = '#5cb85c'; }
            if (stopwatchState === 'running') {
                if (currentTotalElapsedTime > estimatedDurationMs && !arrivalStatus.classList.contains('running-late')) { arrivalStatus.textContent = '‚ö†Ô∏è ƒêang v∆∞·ª£t qu√° m·ª•c ti√™u!'; arrivalStatus.className = 'running-late'; }
                else if (currentTotalElapsedTime <= estimatedDurationMs && arrivalStatus.classList.contains('running-late')) { arrivalStatus.textContent = ''; arrivalStatus.className = ''; }
            }
        } catch (error) { console.error("Error updating progress bar:", error); }
     }

    // === Stopwatch Logic ===
    function updateStopwatchUI(newState) { /* ... */
        stopwatchState = newState; const hasValidTarget = (targetMode === 'time' && targetDateTime) || (targetMode === 'duration' && targetDurationMinutes > 0);
        const isStopwatchActive = (newState === 'running' || newState === 'paused');
        if (isStopwatchActive) { targetControlsWrapper.classList.add('hidden'); }
        else { targetControlsWrapper.classList.remove('hidden'); showCorrectTargetGroup(); }
        startBtn.classList.add('hidden'); pauseBtn.classList.add('hidden'); resumeBtn.classList.add('hidden'); stopBtn.classList.add('hidden'); resetBtn.disabled = true;
        switch (stopwatchState) {
            case 'idle': startBtn.classList.remove('hidden'); startBtn.disabled = !hasValidTarget; resetBtn.disabled = elapsedTime <= 0; break;
            case 'running': pauseBtn.classList.remove('hidden'); stopBtn.classList.remove('hidden'); resetBtn.disabled = false; break;
            case 'paused': resumeBtn.classList.remove('hidden'); stopBtn.classList.remove('hidden'); resetBtn.disabled = false; break;
            case 'stopped': startBtn.classList.remove('hidden'); startBtn.disabled = !hasValidTarget; resetBtn.disabled = false; break;
        }
        targetModeTimeRadio.disabled = isStopwatchActive; targetModeDurationRadio.disabled = isStopwatchActive;
        targetDateInput.disabled = isStopwatchActive; targetTimeInput.disabled = isStopwatchActive; targetDurationInput.disabled = isStopwatchActive;
        setTargetBtn.disabled = isStopwatchActive; setDurationTargetBtn.disabled = isStopwatchActive;
     }

    // --- MODIFIED: stopwatchTick uses innerHTML ---
    function stopwatchTick() {
        if (stopwatchState !== 'running') { stopStopwatchInterval(); return; }
        try {
            const currentRunTime = Date.now() - startTime;
            const currentTotalElapsedTime = elapsedTime + currentRunTime;
            stopwatchDisplay.innerHTML = formatStopwatchTime(currentTotalElapsedTime); // Use innerHTML
            updateProgressBar(currentTotalElapsedTime);
        } catch (error) { console.error("Error in stopwatch tick:", error); finishStopwatch(); }
    }
    // --- END MODIFIED ---

    function startStopwatchInterval() { /* ... */
        stopStopwatchInterval(); startTime = Date.now();
        stopwatchIntervalId = setInterval(stopwatchTick, 50); console.log("Stopwatch interval started with ID:", stopwatchIntervalId);
     }
    function stopStopwatchInterval() { /* ... */
        if (stopwatchIntervalId !== null) { clearInterval(stopwatchIntervalId); console.log("Stopwatch interval cleared:", stopwatchIntervalId); stopwatchIntervalId = null; }
     }
    function startStopwatch() { /* ... */
        const hasValidTarget = (targetMode === 'time' && targetDateTime) || (targetMode === 'duration' && targetDurationMinutes > 0);
        if (stopwatchState !== 'idle' || !hasValidTarget) { if (!hasValidTarget) showMessage("Vui l√≤ng ƒë·∫∑t m·ª•c ti√™u h·ª£p l·ªá tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.", 'warning'); return; }
        console.log("Starting stopwatch in mode:", targetMode); clearMessage(); arrivalStatus.textContent = ''; arrivalStatus.className = '';
        stopwatchStartDate = new Date(); elapsedTime = 0; estimatedDurationMs = 0; projectedTargetDateTime = null;
        if (targetMode === 'time') {
            estimatedDurationMs = targetDateTime.getTime() - stopwatchStartDate.getTime(); projectedTargetDateTime = targetDateTime;
            if (estimatedDurationMs <= 0) { showMessage("L·ªói: Th·ªùi gian m·ª•c ti√™u kh√¥ng h·ª£p l·ªá so v·ªõi th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu.", 'error'); clearTargetState(); updateStopwatchUI('idle'); return; }
        } else {
            estimatedDurationMs = targetDurationMinutes * 60 * 1000; projectedTargetDateTime = new Date(stopwatchStartDate.getTime() + estimatedDurationMs);
            if (estimatedDurationMs <= 0) { showMessage("L·ªói: Th·ªùi l∆∞·ª£ng m·ª•c ti√™u kh√¥ng h·ª£p l·ªá.", 'error'); clearTargetState(); updateStopwatchUI('idle'); return; }
             targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetDurationMinutes} ph√∫t</span> (D·ª± ki·∫øn k·∫øt th√∫c: ${formatTimeHHMMSS(projectedTargetDateTime)})`;
        }
        console.log("Estimated Duration (ms):", estimatedDurationMs, "Projected End:", projectedTargetDateTime);
        updateStopwatchUI('running'); startStopwatchInterval();
        progressBar.style.width = '0%'; progressBar.textContent = '0%'; progressBarContainer.setAttribute('aria-valuenow', '0'); progressBar.style.backgroundColor = '#5cb85c';
     }

    // --- MODIFIED: pauseStopwatch uses innerHTML ---
    function pauseStopwatch() {
        if (stopwatchState !== 'running') return;
        console.log("Pausing stopwatch..."); stopStopwatchInterval();
        const currentRunTime = Date.now() - startTime; elapsedTime += currentRunTime; startTime = 0;
        updateStopwatchUI('paused');
        stopwatchDisplay.innerHTML = formatStopwatchTime(elapsedTime); // Use innerHTML
        updateProgressBar(elapsedTime);
    }
    // --- END MODIFIED ---

    function resumeStopwatch() { /* ... */
        if (stopwatchState !== 'paused') return; console.log("Resuming stopwatch...");
        updateStopwatchUI('running'); startStopwatchInterval();
     }

     // --- MODIFIED: finishStopwatch uses innerHTML ---
    function finishStopwatch() {
        if (stopwatchState !== 'running' && stopwatchState !== 'paused') return;
        console.log("Finishing stopwatch..."); const endTimeMs = Date.now(); stopStopwatchInterval();
        if (stopwatchState === 'running') { const currentRunTime = endTimeMs - startTime; elapsedTime += currentRunTime; }
        startTime = 0;
        stopwatchDisplay.innerHTML = formatStopwatchTime(elapsedTime); // Use innerHTML
        updateProgressBar(elapsedTime);
        if (!stopwatchStartDate || !estimatedDurationMs || estimatedDurationMs <= 0 || !projectedTargetDateTime) { console.error("L·ªói: Thi·∫øu d·ªØ li·ªáu c·∫ßn thi·∫øt khi k·∫øt th√∫c."); showMessage("L·ªói d·ªØ li·ªáu khi k·∫øt th√∫c b·∫•m gi·ªù.", 'error'); resetStopwatch(true); return; }
        const endTime = new Date(endTimeMs); let finalStatusText = ''; let finalStatusClass = '';
        const differenceMs = projectedTargetDateTime.getTime() - endTime.getTime();
        if (targetMode === 'time') {
            const diffMinutes = Math.round(Math.abs(differenceMs) / (1000 * 60)); const diffSeconds = Math.round(Math.abs(differenceMs) / 1000);
            if (differenceMs > 59999) { finalStatusText = `‚úÖ ƒê·∫øn s·ªõm ${diffMinutes} ph√∫t!`; finalStatusClass = 'early'; }
            else if (differenceMs < -59999) { finalStatusText = `‚ùå ƒê√£ mu·ªôn ${diffMinutes} ph√∫t.`; finalStatusClass = 'late'; }
            else { finalStatusText = `üëç ƒê·∫øn g·∫ßn ƒë√∫ng gi·ªù! (${differenceMs >= 0 ? '+' : ''}${diffSeconds} gi√¢y)`; finalStatusClass = 'on-time'; }
        } else {
            const timeDiffReadable = formatDurationReadable(Math.abs(differenceMs));
            if (elapsedTime <= estimatedDurationMs) { finalStatusText = `‚úÖ Ho√†n th√†nh trong ${formatDurationReadable(elapsedTime)}!`; if (differenceMs > 0) { finalStatusText += ` (S·ªõm ${timeDiffReadable})`; } finalStatusClass = 'completed'; }
            else { finalStatusText = `‚ùå V∆∞·ª£t qu√° m·ª•c ti√™u ${timeDiffReadable}. (T·ªïng: ${formatDurationReadable(elapsedTime)})`; finalStatusClass = 'exceeded'; }
        }
        arrivalStatus.textContent = finalStatusText; arrivalStatus.className = finalStatusClass;
        const startDateStr = stopwatchStartDate.toLocaleDateString('vi-VN'); const startTimeStr = formatTimeHHMMSS(stopwatchStartDate); const endTimeStr = formatTimeHHMMSS(endTime);
        const finalDurationStr = formatStopwatchTime(elapsedTime); // This now returns HTML
        const durationMinutesStr = formatDurationReadable(elapsedTime);
        const newEntry = {
            id: Date.now(), targetMode: targetMode, startDateStr, startTimeStr, endTimeStr,
            finalDurationStr: stopwatchDisplay.innerHTML, // Store the generated HTML for history display
            durationMinutesStr, arrivalStatusText: finalStatusText, arrivalStatusClass: finalStatusClass,
            ...(targetMode === 'time' && { targetDateTimeStr: formatTimeHHMMSS(targetDateTime) + ' (' + targetDateTime.toLocaleDateString('vi-VN') + ')' }),
            ...(targetMode === 'duration' && { targetDurationMinutes: targetDurationMinutes, projectedEndTimeStr: formatTimeHHMMSS(projectedTargetDateTime) })
        };
        travelHistory.push(newEntry); saveHistory(); currentPage = 1; displayHistory();
        updateStopwatchUI('stopped');
    }
     // --- END MODIFIED ---

     // --- MODIFIED: resetStopwatch uses innerHTML ---
    function resetStopwatch(clearInputsAndTarget = true) {
        console.log("Resetting stopwatch..."); stopStopwatchInterval();
        elapsedTime = 0; startTime = 0; stopwatchStartDate = null;
        stopwatchDisplay.innerHTML = formatStopwatchTime(0); // Use innerHTML
        if (clearInputsAndTarget) {
            clearTargetState(); setDefaultInputs(); targetMode = 'time'; targetModeTimeRadio.checked = true;
        } else {
             arrivalStatus.textContent = ''; arrivalStatus.className = ''; progressBar.style.width = '0%';
             progressBar.textContent = ''; progressBarContainer.setAttribute('aria-valuenow', '0'); progressBar.style.backgroundColor = '#5cb85c';
        }
        updateStopwatchUI('idle');
    }
    // --- END MODIFIED ---

    // === History Logic ===
    // --- MODIFIED: displayHistory uses innerHTML from entry ---
    function displayHistory() {
        try {
            travelHistoryList.innerHTML = ''; const noHistoryMsgElement = travelHistoryList.querySelector('.no-history-message');
            if (noHistoryMsgElement) noHistoryMsgElement.remove(); clearHistoryBtn.disabled = travelHistory.length === 0;
            if (travelHistory.length === 0) { pageInfo.textContent = 'Kh√¥ng c√≥ l·ªãch s·ª≠'; prevPageBtn.disabled = true; nextPageBtn.disabled = true; travelHistoryList.innerHTML = '<li class="no-history-message">Kh√¥ng c√≥ l·ªãch s·ª≠ n√†o ƒë∆∞·ª£c ghi l·∫°i.</li>'; return; }
            const totalItems = travelHistory.length; const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage > totalPages) currentPage = totalPages; if (currentPage < 1) currentPage = 1;
            const startIndex = (currentPage - 1) * itemsPerPage; const endIndex = startIndex + itemsPerPage;
            const itemsToShow = travelHistory.slice().reverse().slice(startIndex, endIndex);
            console.log(`Displaying history page ${currentPage}/${totalPages}, items ${startIndex}-${endIndex - 1}`);
            itemsToShow.forEach(entry => {
                const li = document.createElement('li'); li.className = 'history-entry';
                let targetDisplay = 'N/A';
                if (entry.targetMode === 'time' && entry.targetDateTimeStr) { targetDisplay = entry.targetDateTimeStr; }
                else if (entry.targetMode === 'duration' && entry.targetDurationMinutes) { targetDisplay = `${entry.targetDurationMinutes} ph√∫t`; }
                const statusHTML = entry.arrivalStatusText ? `<div class="history-status ${entry.arrivalStatusClass || ''}">${entry.arrivalStatusText}</div>` : '';
                // Use the stored HTML for finalDurationStr
                const durationHTML = entry.finalDurationStr || 'N/A';
                li.innerHTML = `
                    <div class="history-row">
                        <div class="history-group"><strong class="history-label">B·∫Øt ƒë·∫ßu:</strong> <span class="history-value">${entry.startTimeStr || 'N/A'} (${entry.startDateStr || 'N/A'})</span></div>
                        <div class="history-group"><strong class="history-label">K·∫øt th√∫c:</strong> <span class="history-value">${entry.endTimeStr || 'N/A'}</span></div>
                    </div>
                    <div class="history-row">
                          <div class="history-group"><strong class="history-label">M·ª•c ti√™u:</strong> <span class="history-value">${targetDisplay}</span></div>
                    </div>
                    <div class="history-row">
                        <div class="history-group"><strong class="history-label">Th·ªùi gian:</strong> <span class="history-value">${durationHTML}</span> <span class="history-value-alt">(${entry.durationMinutesStr || 'N/A'})</span></div>
                    </div>
                    ${statusHTML}
                `;
                travelHistoryList.appendChild(li);
            });
            pageInfo.textContent = `Trang ${currentPage} / ${totalPages}`; prevPageBtn.disabled = currentPage === 1; nextPageBtn.disabled = currentPage === totalPages;
        } catch (error) { console.error("Error displaying history:", error); travelHistoryList.innerHTML = '<li style="color: red; text-align: center;">L·ªói hi·ªÉn th·ªã l·ªãch s·ª≠</li>'; showMessage("Kh√¥ng th·ªÉ hi·ªÉn th·ªã l·ªãch s·ª≠.", 'error'); }
    }
    // --- END MODIFIED ---

    function loadHistory() { /* ... */
        try {
            const saved = localStorage.getItem(HISTORY_STORAGE_KEY); travelHistory = saved ? JSON.parse(saved) : [];
            currentPage = 1; displayHistory(); console.log(`Loaded ${travelHistory.length} history entries.`);
        } catch (error) { console.error("Error loading history:", error); showMessage("L·ªói khi t·∫£i l·ªãch s·ª≠ t·ª´ b·ªô nh·ªõ.", 'error'); travelHistory = []; localStorage.removeItem(HISTORY_STORAGE_KEY); displayHistory(); }
     }
    function saveHistory() { /* ... */
        try { localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(travelHistory)); }
        catch (error) { console.error("Error saving history:", error); showMessage("Kh√¥ng th·ªÉ l∆∞u l·ªãch s·ª≠.", 'error'); }
     }
    function clearTravelHistory() { /* ... */
        if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a TO√ÄN B·ªò l·ªãch s·ª≠ kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.")) { travelHistory = []; saveHistory(); currentPage = 1; displayHistory(); showMessage("ƒê√£ x√≥a to√†n b·ªô l·ªãch s·ª≠.", 'success'); }
     }

    // === Wake Lock Logic ===
    async function toggleWakeLock() { /* ... */
        if (!('wakeLock' in navigator)) { showMessage('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng gi·ªØ m√†n h√¨nh s√°ng.', 'warning'); return; }
        try {
            if (wakeLock) { await wakeLock.release(); wakeLock = null; console.log('Wake Lock released.'); wakeLockBtn.classList.remove('active'); wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng'; showMessage('ƒê√£ t·∫Øt ch·∫ø ƒë·ªô gi·ªØ m√†n h√¨nh s√°ng.', 'info'); }
            else { wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', () => { console.log('Wake Lock was released automatically.'); wakeLock = null; wakeLockBtn.classList.remove('active'); wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng'; }); console.log('Wake Lock active.'); wakeLockBtn.classList.add('active'); wakeLockBtn.title = 'ƒêang gi·ªØ m√†n h√¨nh s√°ng (Nh·∫•n ƒë·ªÉ t·∫Øt)'; showMessage('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô gi·ªØ m√†n h√¨nh s√°ng.', 'success'); }
        } catch (err) { console.error(`Wake Lock Error: ${err.name}, ${err.message}`); wakeLock = null; wakeLockBtn.classList.remove('active'); wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng (L·ªói)'; showMessage(`L·ªói Wake Lock: ${err.message}`, 'error'); }
     }
    async function handleVisibilityChange() { /* ... */
        if (wakeLock !== null && document.visibilityState === 'visible') { try { await toggleWakeLock(); await toggleWakeLock(); console.log('Wake Lock re-acquired on visibility change.'); } catch (err) { console.error('Failed to re-acquire Wake Lock:', err); showMessage('Kh√¥ng th·ªÉ t·ª± ƒë·ªông b·∫≠t l·∫°i ch·∫ø ƒë·ªô gi·ªØ s√°ng.', 'warning'); } }
     }

    // === Initialization ===
    function setDefaultInputs() { /* ... */
        targetDateInput.value = formatDateYYYYMMDD(new Date()); targetTimeInput.value = "06:55"; targetDurationInput.value = '';
     }
    function loadPreferences() { /* ... */
        const savedFormat = localStorage.getItem(FORMAT_STORAGE_KEY); is24HourFormat = (savedFormat === '24'); formatToggleButton.textContent = is24HourFormat ? '12h' : '24h'; updateClock();
        const savedMode = localStorage.getItem(TARGET_MODE_STORAGE_KEY); targetMode = (savedMode === 'duration') ? 'duration' : 'time';
        if (targetMode === 'duration') targetModeDurationRadio.checked = true; else targetModeTimeRadio.checked = true;
     }
    function savePreferences() { /* ... */
        localStorage.setItem(FORMAT_STORAGE_KEY, is24HourFormat ? '24' : '12'); localStorage.setItem(TARGET_MODE_STORAGE_KEY, targetMode);
     }

    function initializeApp() {
        console.log("Initializing App (v6 - Smaller MS)...");
        try {
            if (mainClockIntervalId) clearInterval(mainClockIntervalId); if (stopwatchIntervalId) clearInterval(stopwatchIntervalId); mainClockIntervalId = null; stopwatchIntervalId = null;
            mainClockIntervalId = setInterval(updateClock, 1000); loadPreferences(); updateClock(); console.log("Main clock interval started with ID:", mainClockIntervalId);
            setDefaultInputs(); showCorrectTargetGroup();
            // Event Listeners
            formatToggleButton.addEventListener('click', () => { is24HourFormat = !is24HourFormat; formatToggleButton.textContent = is24HourFormat ? '12h' : '24h'; savePreferences(); updateClock(); });
            targetModeTimeRadio.addEventListener('change', handleTargetModeChange); targetModeDurationRadio.addEventListener('change', handleTargetModeChange);
            setTargetBtn.addEventListener('click', setTarget); setDurationTargetBtn.addEventListener('click', setTarget);
            startBtn.addEventListener('click', startStopwatch); pauseBtn.addEventListener('click', pauseStopwatch); resumeBtn.addEventListener('click', resumeStopwatch);
            stopBtn.addEventListener('click', finishStopwatch); resetBtn.addEventListener('click', () => resetStopwatch(true)); clearHistoryBtn.addEventListener('click', clearTravelHistory);
            prevPageBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage--; displayHistory(); } }); nextPageBtn.addEventListener('click', () => { const totalPages = Math.ceil(travelHistory.length / itemsPerPage); if (currentPage < totalPages) { currentPage++; displayHistory(); } });
            if (!('wakeLock' in navigator)) { wakeLockBtn.disabled = true; wakeLockBtn.title = 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng n√†y'; } else { wakeLockBtn.addEventListener('click', toggleWakeLock); document.addEventListener('visibilitychange', handleVisibilityChange); }
            loadHistory();
            resetStopwatch(false); // Calls updateStopwatchUI('idle')
            stopwatchDisplay.innerHTML = formatStopwatchTime(0); // Set initial display with HTML

            console.log("App Initialized Successfully.");
        } catch (error) { console.error("Error during app initialization:", error); showMessage("ƒê√£ x·∫£y ra l·ªói nghi√™m tr·ªçng khi kh·ªüi t·∫°o ·ª©ng d·ª•ng. Vui l√≤ng th·ª≠ t·∫£i l·∫°i trang.", 'error', 0); }
    }

    // Run Initialization
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeApp); }
    else { initializeApp(); }
</script>

</body>
</html>
