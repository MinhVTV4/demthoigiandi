<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê·ªìng H·ªì Web - M·ª•c ti√™u Th·ªùi l∆∞·ª£ng</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400..700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Body Styles */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Allow scrolling */
            min-height: 100vh;
            background-color: #1e223a; /* Dark blue background */
            font-family: 'Roboto', sans-serif;
            color: #e0e0e0; /* Light text color */
            overflow-y: auto; /* Enable vertical scroll */
            padding: 40px 15px; /* Add padding top/bottom and sides */
        }

        /* Main Container */
        .clock-container {
            width: 100%;
            max-width: 700px;
            text-align: center;
            position: relative;
            background-color: rgba(40, 45, 70, 0.7);
            padding: 60px 5% 40px 5%;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Top Controls (Wake Lock, Format Toggle) */
        .top-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            gap: 10px;
            z-index: 10;
        }
        .top-controls button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8rem;
            font-weight: 500;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
        }
        .top-controls button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .top-controls button:active:not(:disabled) { transform: scale(0.95); }
        .top-controls button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(80%); }
        #wake-lock-btn.active { background-color: #f0a500; color: #111; border-color: #f0a500; font-weight: bold; }

        /* Message Area */
        .message-area {
            min-height: 1.5em;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-weight: 500;
            text-align: center;
            transition: opacity 0.3s ease;
        }
        .message-area.error { color: #d9534f; }
        .message-area.success { color: #5cb85c; }
        .message-area.info { color: #5bc0de; }
        .message-area.warning { color: #f0ad4e; }
        .message-area:empty { opacity: 0; }

        /* Digital Clock Display */
        .digital-clock {
            font-weight: 500;
            margin-bottom: 5px;
            letter-spacing: 1px;
            display: flex;
            justify-content: center;
            align-items: baseline;
            flex-wrap: wrap;
            color: #66fcf1;
            text-shadow: 0 0 10px rgba(102, 252, 241, 0.3);
        }
        #hours, #minutes, #seconds, .colon, .ampm {
            font-family: 'Roboto Mono', monospace;
            display: inline-block;
            line-height: 1;
        }
        #hours, #minutes, #seconds { font-size: clamp(3.5rem, 16vw, 6.5rem); }
        .colon { font-size: clamp(3rem, 14vw, 5.5rem); margin: 0 clamp(-2px, 0.5vw, 3px); opacity: 0.85; }
        .ampm {
            font-family: 'Roboto', sans-serif;
            font-size: clamp(1.3rem, 5vw, 2rem);
            font-weight: 500;
            color: #66fcf1;
            margin-left: clamp(5px, 1.5vw, 10px);
            text-transform: uppercase;
            opacity: 0.9;
            align-self: flex-end;
            padding-bottom: calc(clamp(3.5rem, 16vw, 6.5rem) * 0.1);
        }

        /* Date Display */
        .date-display {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            margin-top: 0;
            margin-bottom: 35px;
            color: #bdc3c7;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Target Section */
        .target-section {
            margin-bottom: 35px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        /* NEW: Target Mode Selector */
        .target-mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }
        .target-mode-selector label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ccc;
        }
        .target-mode-selector input[type="radio"] {
            cursor: pointer;
            accent-color: #66fcf1; /* Match accent color */
        }

        /* Input Groups (Time, Duration) */
        .target-input-group, .target-duration-group {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .target-input-group label, .target-duration-group label {
            font-size: 0.95rem;
            color: #ccc;
            white-space: nowrap;
        }
        .target-input-group input[type="date"],
        .target-input-group input[type="time"],
        .target-duration-group input[type="number"] { /* Added duration input */
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #eee;
            padding: 9px 12px;
            border-radius: 6px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            height: 40px;
            box-sizing: border-box;
        }
        .target-input-group input[type="date"] { min-width: 140px; }
        .target-input-group input[type="time"] { min-width: 115px; }
        .target-duration-group input[type="number"] { min-width: 100px; text-align: right; } /* Style duration input */

        .target-input-group input[type="date"]::-webkit-calendar-picker-indicator,
        .target-input-group input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8);
            cursor: pointer;
        }

        /* --- MODIFIED: Apply common styles to BOTH buttons --- */
        #set-target-btn, #set-duration-target-btn {
            background-color: #5bc0de; /* Info blue */
            color: #fff;
            border: none;
            padding: 0 18px; /* Padding left/right */
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            height: 40px; /* Consistent height */
            box-sizing: border-box;
            line-height: 40px; /* Center text vertically */
            margin-left: 5px; /* Add some space before button */
        }
        #set-target-btn:hover:not(:disabled),
        #set-duration-target-btn:hover:not(:disabled) {
             filter: brightness(1.15);
        }
        #set-target-btn:active:not(:disabled),
        #set-duration-target-btn:active:not(:disabled) {
            transform: scale(0.96);
        }
        #set-target-btn:disabled,
        #set-duration-target-btn:disabled, /* Apply disabled styles to both */
        .target-input-group input:disabled,
        .target-duration-group input:disabled {
            background-color: #777;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* --- END MODIFIED --- */


        /* Target Info & Status */
        #target-info {
            font-size: 0.95rem;
            color: #bbb;
            min-height: 1.2em;
            margin-bottom: 8px;
            font-style: italic;
        }
        #target-info span { font-weight: bold; color: #f0a500; font-style: normal; } /* Orange for target */
        #arrival-status {
            font-size: 0.95rem;
            font-weight: bold;
            min-height: 1.2em;
            margin-bottom: 15px;
            transition: color 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }
        #arrival-status:empty { opacity: 0; }
        /* Status classes for Time mode */
        #arrival-status.early { color: #5cb85c; } /* Green */
        #arrival-status.late { color: #d9534f; } /* Red */
        #arrival-status.on-time { color: #5bc0de; } /* Blue */
        /* Status classes for Duration mode */
        #arrival-status.completed { color: #5cb85c; } /* Green */
        #arrival-status.exceeded { color: #d9534f; } /* Red */
        /* Common status */
        #arrival-status.running-late { color: #f0ad4e; font-style: italic; } /* Orange */

        /* Progress Bar */
        .progress-bar-container {
            width: 100%;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            border-radius: 12px;
            transition: width 0.2s linear, background-color 0.3s ease;
            text-align: center;
            color: rgba(0, 0, 0, 0.8);
            font-size: 0.85rem;
            line-height: 24px;
            font-weight: bold;
            box-sizing: border-box;
            white-space: nowrap;
            background-color: #5cb85c;
        }

        /* Stopwatch Section */
        .stopwatch-section { margin-top: 0; padding-top: 0; }
        #stopwatch-display {
            font-family: 'Roboto Mono', monospace;
            font-size: clamp(2.2rem, 9vw, 3.5rem);
            color: #f0a500;
            margin-bottom: 35px;
            letter-spacing: 1px;
            font-weight: 500;
            word-break: break-all;
        }
        .stopwatch-controls {
            margin-bottom: 35px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px 15px;
        }
        .stopwatch-controls button {
            border: none;
            color: #fff;
            padding: 12px 25px;
            margin: 0;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
            min-width: 120px;
        }
        .stopwatch-controls button#start-btn { background-color: #5cb85c; }
        .stopwatch-controls button#pause-btn { background-color: #f0ad4e; }
        .stopwatch-controls button#resume-btn { background-color: #5bc0de; }
        .stopwatch-controls button#stop-btn { background-color: #d9534f; }
        .stopwatch-controls button#reset-btn { background-color: #777; }
        .stopwatch-controls button#clear-history-btn {
            background-color: #6c757d;
            font-size: 0.9rem;
            min-width: auto;
            padding: 10px 20px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }
        .stopwatch-controls button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }
        .stopwatch-controls button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
        }
        .stopwatch-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
            box-shadow: none;
        }

        /* History Section */
        .history-section {
            margin-top: 45px;
            padding-top: 25px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }
        .history-section h3 {
            color: #ccc;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-align: left;
            font-weight: 500;
        }
        #travel-history-list {
            list-style: none;
            padding: 0;
            margin: 0;
            min-height: 150px;
            text-align: left;
            margin-bottom: 25px;
        }
        .history-entry {
            background-color: rgba(255, 255, 255, 0.04);
            border-radius: 8px;
            padding: 18px;
            margin-bottom: 15px;
            border-left: 5px solid #f0a500;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .history-entry:hover { background-color: rgba(255, 255, 255, 0.08); }
        .history-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            flex-wrap: wrap;
            gap: 5px 15px;
        }
        .history-group { display: flex; align-items: baseline; gap: 6px; }
        .history-label { color: #bbb; font-weight: 500; min-width: 70px; text-align: left; }
        .history-value { font-family: 'Roboto Mono', monospace; color: #f0a500; font-weight: bold; text-align: left; }
        .history-value-alt { font-family: 'Roboto', sans-serif; font-size: 0.85em; color: #ccc; margin-left: 5px; }
        .history-status { margin-top: 8px; font-weight: bold; font-size: 0.9em; width: 100%; }
        /* Status classes need to match arrival-status */
        .history-status.early, .history-status.completed { color: #5cb85c; }
        .history-status.late, .history-status.exceeded { color: #d9534f; }
        .history-status.on-time { color: #5bc0de; }
        .no-history-message {
            text-align: center; color: #888; padding: 30px 0; font-style: italic;
        }

        /* Pagination Controls */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .pagination-controls button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ccc;
            padding: 7px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.85rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
        }
        .pagination-controls button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.25);
        }
        .pagination-controls button:active:not(:disabled) { transform: scale(0.95); }
        .pagination-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        #page-info { font-size: 0.85rem; color: #aaa; white-space: nowrap; }

        /* Utility Classes */
        .hidden { display: none !important; }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            body { padding: 25px 10px; }
            .clock-container { padding: 50px 4% 30px 4%; }
            .top-controls { top: 15px; right: 15px; }
            #hours, #minutes, #seconds { font-size: clamp(3rem, 18vw, 5.5rem); }
            .colon { font-size: clamp(2.5rem, 16vw, 4.5rem); }
            .ampm { font-size: clamp(1.1rem, 6vw, 1.7rem); }
            .date-display { font-size: clamp(0.9rem, 4vw, 1.1rem); }
            /* Adjust target groups for mobile */
            .target-mode-selector { gap: 15px; margin-bottom: 15px;}
            .target-input-group, .target-duration-group { flex-direction: column; align-items: stretch; gap: 12px; }
            .target-input-group label, .target-duration-group label { text-align: center; }
            .target-input-group input[type="date"],
            .target-input-group input[type="time"],
            .target-duration-group input[type="number"],
            /* Apply to both buttons on mobile */
            #set-target-btn, #set-duration-target-btn {
                 width: 100%; min-width: unset; margin-left: 0;
            }

            #stopwatch-display { font-size: clamp(1.8rem, 10vw, 3rem); }
            .stopwatch-controls { gap: 10px; }
            .stopwatch-controls button { min-width: 100px; padding: 10px 20px; font-size: 0.9rem; }
            .history-entry { padding: 15px; }
            .history-row { flex-direction: column; align-items: flex-start; gap: 3px; }
            .history-group { width: 100%; justify-content: space-between; }
            .history-label { min-width: 60px; }
        }
        @media (max-width: 400px) {
            #hours, #minutes, #seconds { font-size: clamp(2.5rem, 20vw, 4.5rem); }
            .colon { font-size: clamp(2rem, 18vw, 3.5rem); }
            .ampm { font-size: clamp(1rem, 7vw, 1.5rem); }
            .stopwatch-controls button { min-width: 90px; padding: 10px 15px; font-size: 0.85rem; }
            .pagination-controls button { padding: 6px 10px; font-size: 0.8rem;}
            #page-info { font-size: 0.8rem; }
        }

    </style>
</head>
<body>

<div class="clock-container">
    <div class="top-controls">
        <button id="wake-lock-btn" title="Gi·ªØ m√†n h√¨nh s√°ng (n·∫øu tr√¨nh duy·ªát h·ªó tr·ª£)">Gi·ªØ s√°ng</button>
        <button id="format-toggle-btn" title="ƒê·ªïi ƒë·ªãnh d·∫°ng 12/24 gi·ªù">24h</button>
    </div>

    <div id="message-area" class="message-area" aria-live="polite"></div>

    <div class="digital-clock">
        <span id="hours">00</span><span class="colon">:</span><span id="minutes">00</span><span class="colon">:</span><span id="seconds">00</span>
        <span id="ampm" class="ampm"></span>
    </div>
    <div class="date-display" id="date"></div>

    <div class="target-section">
        <div class="target-mode-selector">
            <label>
                <input type="radio" name="target-mode" value="time" id="target-mode-time" checked>
                Theo Th·ªùi ƒëi·ªÉm
            </label>
            <label>
                <input type="radio" name="target-mode" value="duration" id="target-mode-duration">
                Theo Th·ªùi l∆∞·ª£ng
            </label>
        </div>

        <div id="target-time-group" class="target-input-group">
            <label for="target-date">Ng√†y:</label>
            <input type="date" id="target-date" name="target-date">
            <label for="target-time">Gi·ªù:</label>
            <input type="time" id="target-time" name="target-time">
            <button id="set-target-btn">ƒê·∫∑t M·ª•c Ti√™u</button>
        </div>

        <div id="target-duration-group" class="target-duration-group hidden">
            <label for="target-duration-input">Th·ªùi l∆∞·ª£ng (ph√∫t):</label>
            <input type="number" id="target-duration-input" name="target-duration" min="1" step="1">
            <button id="set-duration-target-btn">ƒê·∫∑t M·ª•c Ti√™u</button>
        </div>

        <div id="target-info" aria-live="polite">Ch∆∞a ƒë·∫∑t m·ª•c ti√™u</div>
        <div id="arrival-status" aria-live="polite"></div>
        <div class="progress-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div class="stopwatch-section">
        <div id="stopwatch-display" aria-live="polite">00:00:00.000</div>
        <div class="stopwatch-controls">
            <button id="start-btn" disabled>B·∫Øt ƒë·∫ßu</button>
            <button id="pause-btn" class="hidden">T·∫°m d·ª´ng</button>
            <button id="resume-btn" class="hidden">Ti·∫øp t·ª•c</button>
            <button id="stop-btn" class="hidden">K·∫øt th√∫c</button>
            <button id="reset-btn" disabled>Reset</button>
            <button id="clear-history-btn">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <div class="history-section">
        <h3>L·ªãch s·ª≠ Di chuy·ªÉn / Ho√†n th√†nh</h3>
        <ul id="travel-history-list">
            <li class="no-history-message">Kh√¥ng c√≥ l·ªãch s·ª≠ n√†o ƒë∆∞·ª£c ghi l·∫°i.</li>
        </ul>
        <div class="pagination-controls">
            <button id="prev-page-btn" disabled>Tr∆∞·ªõc</button>
            <span id="page-info">Trang 1 / 1</span>
            <button id="next-page-btn" disabled>Sau</button>
        </div>
    </div>
</div>

<script>
    // === DOM Element References ===
    const hoursElement = document.getElementById('hours');
    const minutesElement = document.getElementById('minutes');
    const secondsElement = document.getElementById('seconds');
    const ampmElement = document.getElementById('ampm');
    const dateElement = document.getElementById('date');
    const formatToggleButton = document.getElementById('format-toggle-btn');
    // Target Mode Elements
    const targetModeTimeRadio = document.getElementById('target-mode-time');
    const targetModeDurationRadio = document.getElementById('target-mode-duration');
    const targetTimeGroup = document.getElementById('target-time-group');
    const targetDurationGroup = document.getElementById('target-duration-group');
    // Time Target Inputs
    const targetDateInput = document.getElementById('target-date');
    const targetTimeInput = document.getElementById('target-time');
    // Duration Target Input
    const targetDurationInput = document.getElementById('target-duration-input');
    // Common Target Elements
    const setTargetBtn = document.getElementById('set-target-btn'); // Button for time mode
    const setDurationTargetBtn = document.getElementById('set-duration-target-btn'); // Button for duration mode
    const targetInfo = document.getElementById('target-info');
    const arrivalStatus = document.getElementById('arrival-status');
    const progressBarContainer = document.querySelector('.progress-bar-container');
    const progressBar = document.getElementById('progress-bar');
    // Stopwatch Elements
    const stopwatchDisplay = document.getElementById('stopwatch-display');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const clearHistoryBtn = document.getElementById('clear-history-btn');
    // History Elements
    const travelHistoryList = document.getElementById('travel-history-list');
    const prevPageBtn = document.getElementById('prev-page-btn');
    const nextPageBtn = document.getElementById('next-page-btn');
    const pageInfo = document.getElementById('page-info');
    // Other Elements
    const wakeLockBtn = document.getElementById('wake-lock-btn');
    const messageArea = document.getElementById('message-area');

    // === State Variables ===
    let is24HourFormat = false;
    let mainClockIntervalId = null;
    let stopwatchIntervalId = null;
    let stopwatchState = 'idle'; // 'idle', 'running', 'paused', 'stopped'
    let startTime = 0;
    let elapsedTime = 0;
    let stopwatchStartDate = null; // Actual Date when stopwatch *first* started
    // Target State
    let targetMode = 'time'; // 'time' or 'duration' - NEW
    let targetDateTime = null; // Date object for 'time' mode
    let targetDurationMinutes = null; // Number of minutes for 'duration' mode - NEW
    let estimatedDurationMs = 0; // Calculated duration based on target mode
    let projectedTargetDateTime = null; // Calculated target Date even in duration mode - NEW (for comparison)
    // History State
    let travelHistory = [];
    let currentPage = 1;
    const itemsPerPage = 5;
    // Other State
    let wakeLock = null;
    let messageTimeoutId = null;

    // === LocalStorage Keys ===
    const HISTORY_STORAGE_KEY = 'travelClockHistory_v4'; // Incremented version
    const FORMAT_STORAGE_KEY = 'clockFormatPreference';
    const TARGET_MODE_STORAGE_KEY = 'targetModePreference'; // NEW: Save target mode preference

    // === Utility Functions ===
    function formatNumber(num) { return num < 10 ? '0' + num : num; }

    function formatTimeHHMMSS(date) {
        if (!date || !(date instanceof Date) || isNaN(date)) return 'N/A';
        try {
            const hours = formatNumber(date.getHours());
            const minutes = formatNumber(date.getMinutes());
            const seconds = formatNumber(date.getSeconds());
            return `${hours}:${minutes}:${seconds}`;
        } catch (error) {
            console.error("Error formatting HHMMSS:", error, date);
            return 'L·ªói gi·ªù';
        }
    }

    function formatDateYYYYMMDD(date) {
        if (!date || !(date instanceof Date) || isNaN(date)) return '';
        try {
            const year = date.getFullYear();
            const month = formatNumber(date.getMonth() + 1);
            const day = formatNumber(date.getDate());
            return `${year}-${month}-${day}`;
        } catch (error) {
            console.error("Error formatting YYYYMMDD:", error, date);
            return '';
        }
    }

    function formatStopwatchTime(timeMs) {
        if (typeof timeMs !== 'number' || isNaN(timeMs) || timeMs < 0) timeMs = 0;
        try {
            const totalSeconds = Math.floor(timeMs / 1000);
            const hours = formatNumber(Math.floor(totalSeconds / 3600));
            const minutes = formatNumber(Math.floor((totalSeconds % 3600) / 60));
            const seconds = formatNumber(totalSeconds % 60);
            const milliseconds = String(Math.floor(timeMs % 1000)).padStart(3, '0');
            return `${hours}:${minutes}:${seconds}.${milliseconds}`;
        } catch (error) {
            console.error("Error formatting stopwatch time:", error, timeMs);
            return '00:00:00.000';
        }
    }

    // Format duration in milliseconds to a readable string (e.g., "15 ph√∫t 32 gi√¢y")
    function formatDurationReadable(timeMs) {
        if (typeof timeMs !== 'number' || isNaN(timeMs) || timeMs < 0) return 'N/A';
        try {
            const totalSeconds = Math.round(timeMs / 1000); // Round to nearest second
            if (totalSeconds < 60) {
                return `${totalSeconds} gi√¢y`;
            }
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (seconds === 0) {
                return `${minutes} ph√∫t`;
            }
            return `${minutes} ph√∫t ${seconds} gi√¢y`;
        } catch (error) {
            console.error("Error formatting readable duration:", error, timeMs);
            return 'L·ªói th·ªùi gian';
        }
    }


    function showMessage(text, type = 'info', duration = 3000) {
        if (messageTimeoutId) clearTimeout(messageTimeoutId);
        messageArea.textContent = text;
        messageArea.className = `message-area ${type}`;
        messageArea.style.opacity = 1;
        if (duration > 0) {
            messageTimeoutId = setTimeout(() => {
                messageArea.style.opacity = 0;
            }, duration);
        }
    }

    function clearMessage() {
        if (messageTimeoutId) clearTimeout(messageTimeoutId);
        messageArea.textContent = '';
        messageArea.className = 'message-area';
        messageArea.style.opacity = 0;
    }

    // === Main Clock Logic ===
    function updateClock() {
        try {
            const now = new Date();
            let hours = now.getHours();
            const minutes = formatNumber(now.getMinutes());
            const secondsValue = formatNumber(now.getSeconds());
            let displayHours = hours;
            if (!is24HourFormat) {
                const ampm = hours >= 12 ? 'PM' : 'AM';
                displayHours = hours % 12;
                displayHours = displayHours ? displayHours : 12;
                ampmElement.textContent = ampm;
                ampmElement.classList.remove('hidden');
            } else {
                ampmElement.classList.add('hidden');
            }
            hoursElement.textContent = formatNumber(displayHours);
            minutesElement.textContent = minutes;
            secondsElement.textContent = secondsValue;
            const day = formatNumber(now.getDate());
            const month = formatNumber(now.getMonth() + 1);
            const year = now.getFullYear();
            const dayOfWeek = now.toLocaleDateString('vi-VN', { weekday: 'long' });
            const dateString = `${dayOfWeek}, ${day}/${month}/${year}`;
            dateElement.textContent = dateString;
        } catch (error) {
            console.error("Error updating main clock:", error);
        }
    }

    // === Target Mode Logic ===
    // NEW: Handle switching between target modes
    function handleTargetModeChange() {
        targetMode = document.querySelector('input[name="target-mode"]:checked').value;
        console.log("Target mode changed to:", targetMode);
        savePreferences(); // Save the new mode preference

        // Show/hide the correct input group AND ITS BUTTON
        if (targetMode === 'time') {
            targetTimeGroup.classList.remove('hidden');
            targetDurationGroup.classList.add('hidden');
        } else { // duration mode
            targetTimeGroup.classList.add('hidden');
            targetDurationGroup.classList.remove('hidden');
        }

        // Clear existing target and reset related UI when mode changes
        clearTargetState();
        updateStopwatchUI('idle'); // Reset button states etc.
    }

    // NEW: Clear target-related state variables and UI
    function clearTargetState() {
        targetDateTime = null;
        targetDurationMinutes = null;
        estimatedDurationMs = 0;
        projectedTargetDateTime = null;
        targetInfo.textContent = 'Ch∆∞a ƒë·∫∑t m·ª•c ti√™u';
        arrivalStatus.textContent = '';
        arrivalStatus.className = '';
        progressBar.style.width = '0%';
        progressBar.textContent = '';
        progressBarContainer.setAttribute('aria-valuenow', '0');
        progressBar.style.backgroundColor = '#5cb85c';
        // Don't reset stopwatch time (elapsedTime) here, only target
    }


    // === Target Setting Logic ===
    // MODIFIED: Handles setting target for BOTH modes
    function setTarget() {
        clearMessage();
        clearTargetState(); // Clear previous target info first

        let isValidTarget = false;

        if (targetMode === 'time') {
            // --- Set Target by Time ---
            const dateValue = targetDateInput.value;
            const timeValue = targetTimeInput.value;
            if (!dateValue || !timeValue) {
                showMessage('Vui l√≤ng ch·ªçn c·∫£ ng√†y v√† gi·ªù m·ª•c ti√™u.', 'error');
                return;
            }
            try {
                const dateTimeString = `${dateValue}T${timeValue}:00`;
                const potentialTargetDate = new Date(dateTimeString);
                if (isNaN(potentialTargetDate)) {
                    showMessage('Ng√†y ho·∫∑c gi·ªù m·ª•c ti√™u kh√¥ng h·ª£p l·ªá.', 'error');
                    return;
                }
                const now = new Date();
                if (potentialTargetDate <= now) {
                    showMessage('Th·ªùi gian m·ª•c ti√™u ph·∫£i ·ªü trong t∆∞∆°ng lai.', 'warning', 5000);
                    // Allow past time but warn
                }
                targetDateTime = potentialTargetDate; // Store the Date object
                projectedTargetDateTime = targetDateTime; // For time mode, projected is the same
                const targetDateStr = targetDateTime.toLocaleDateString('vi-VN');
                const targetTimeStr = formatTimeHHMMSS(targetDateTime);
                targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetTimeStr} (${targetDateStr})</span>`;
                isValidTarget = true;
            } catch (error) {
                console.error("Error setting target time:", error);
                showMessage("ƒê√£ x·∫£y ra l·ªói khi ƒë·∫∑t m·ª•c ti√™u th·ªùi gian.", 'error');
                targetInfo.textContent = 'L·ªói ƒë·∫∑t m·ª•c ti√™u';
                targetDateTime = null;
            }
        } else {
            // --- Set Target by Duration ---
            const durationValue = parseInt(targetDurationInput.value, 10);
            if (isNaN(durationValue) || durationValue <= 0) {
                showMessage('Vui l√≤ng nh·∫≠p th·ªùi l∆∞·ª£ng m·ª•c ti√™u h·ª£p l·ªá (s·ªë ph√∫t > 0).', 'error');
                targetDurationInput.focus(); // Focus the input
                return;
            }
            try {
                targetDurationMinutes = durationValue; // Store the duration
                targetDateTime = null; // Explicitly null for duration mode initially
                projectedTargetDateTime = null; // Will be calculated on start
                targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetDurationMinutes} ph√∫t</span>`;
                isValidTarget = true;
            } catch (error) {
                console.error("Error setting target duration:", error);
                showMessage("ƒê√£ x·∫£y ra l·ªói khi ƒë·∫∑t m·ª•c ti√™u th·ªùi l∆∞·ª£ng.", 'error');
                targetInfo.textContent = 'L·ªói ƒë·∫∑t m·ª•c ti√™u';
                targetDurationMinutes = null;
            }
        }

        // --- Common actions after setting target ---
        if (isValidTarget) {
            showMessage('ƒê√£ ƒë·∫∑t m·ª•c ti√™u th√†nh c√¥ng!', 'success');
            // Reset stopwatch state if it was running/paused, but keep the new target
            if (stopwatchState === 'running' || stopwatchState === 'paused') {
                resetStopwatch(false); // Reset stopwatch logic, keep inputs and new target
            } else {
                 // If idle or stopped, just reset display and elapsed time
                 elapsedTime = 0;
                 stopwatchDisplay.textContent = formatStopwatchTime(0);
            }
             updateStopwatchUI('idle'); // Update button states (Start should be enabled now)
        } else {
            updateStopwatchUI('idle'); // Ensure Start is disabled if target is invalid
        }
        console.log("Target set - Mode:", targetMode, "DateTime:", targetDateTime, "DurationMins:", targetDurationMinutes);
    }


    // === Progress Bar Logic ===
    // MODIFIED: Now uses estimatedDurationMs which is set based on mode
    function updateProgressBar(currentTotalElapsedTime) {
        // Check if we have a valid estimated duration to calculate progress
        if (!estimatedDurationMs || estimatedDurationMs <= 0) {
            progressBar.style.width = '0%';
            progressBar.textContent = '';
            progressBarContainer.setAttribute('aria-valuenow', '0');
            return;
        }

        try {
            let progressPercent = (currentTotalElapsedTime / estimatedDurationMs) * 100;
            progressPercent = Math.max(0, Math.min(100, progressPercent));

            progressBar.style.width = progressPercent.toFixed(1) + '%';
            progressBar.textContent = progressPercent.toFixed(0) + '%';
            progressBarContainer.setAttribute('aria-valuenow', progressPercent.toFixed(0));

            // Change color based on progress
            if (progressPercent >= 90) {
                progressBar.style.backgroundColor = '#d9534f'; // Red
            } else if (progressPercent >= 60) {
                progressBar.style.backgroundColor = '#f0ad4e'; // Orange
            } else {
                progressBar.style.backgroundColor = '#5cb85c'; // Green
            }

            // Update running late status only if stopwatch is running
            // This logic works for both modes as it compares current elapsed time vs estimated duration
            if (stopwatchState === 'running') {
                if (currentTotalElapsedTime > estimatedDurationMs && !arrivalStatus.classList.contains('running-late')) {
                     // Changed condition to > estimatedDurationMs
                    arrivalStatus.textContent = '‚ö†Ô∏è ƒêang v∆∞·ª£t qu√° m·ª•c ti√™u!';
                    arrivalStatus.className = 'running-late';
                } else if (currentTotalElapsedTime <= estimatedDurationMs && arrivalStatus.classList.contains('running-late')) {
                    // Clear running-late status if back within target (e.g., target changed - less likely now)
                    arrivalStatus.textContent = '';
                    arrivalStatus.className = '';
                }
            }
        } catch (error) {
            console.error("Error updating progress bar:", error);
        }
    }

    // === Stopwatch Logic ===

    // MODIFIED: Update UI based on state AND whether a valid target is set
    function updateStopwatchUI(newState) {
        stopwatchState = newState;

        // Determine if a valid target is currently set
        const hasValidTarget = (targetMode === 'time' && targetDateTime) || (targetMode === 'duration' && targetDurationMinutes > 0);

        // Default UI states
        startBtn.classList.add('hidden');
        pauseBtn.classList.add('hidden');
        resumeBtn.classList.add('hidden');
        stopBtn.classList.add('hidden');
        resetBtn.disabled = true;
        // Disable target inputs/mode selection while stopwatch is active
        const isStopwatchActive = (newState === 'running' || newState === 'paused');
        targetModeTimeRadio.disabled = isStopwatchActive;
        targetModeDurationRadio.disabled = isStopwatchActive;
        targetDateInput.disabled = isStopwatchActive;
        targetTimeInput.disabled = isStopwatchActive;
        targetDurationInput.disabled = isStopwatchActive;
        setTargetBtn.disabled = isStopwatchActive; // Disable both set buttons
        setDurationTargetBtn.disabled = isStopwatchActive;


        switch (stopwatchState) {
            case 'idle':
                startBtn.classList.remove('hidden');
                startBtn.disabled = !hasValidTarget; // Enable Start only if a valid target exists
                resetBtn.disabled = elapsedTime <= 0; // Enable Reset only if there's time elapsed
                break;
            case 'running':
                pauseBtn.classList.remove('hidden');
                stopBtn.classList.remove('hidden');
                resetBtn.disabled = false;
                break;
            case 'paused':
                resumeBtn.classList.remove('hidden');
                stopBtn.classList.remove('hidden');
                resetBtn.disabled = false;
                break;
            case 'stopped':
                startBtn.classList.remove('hidden');
                startBtn.disabled = !hasValidTarget; // Allow starting new run if target exists
                resetBtn.disabled = false; // Allow reset after finishing
                break;
        }
    }

    function stopwatchTick() {
        if (stopwatchState !== 'running') {
            stopStopwatchInterval();
            return;
        }
        try {
            const currentRunTime = Date.now() - startTime;
            const currentTotalElapsedTime = elapsedTime + currentRunTime;
            stopwatchDisplay.textContent = formatStopwatchTime(currentTotalElapsedTime);
            updateProgressBar(currentTotalElapsedTime); // Progress depends on estimatedDurationMs
        } catch (error) {
            console.error("Error in stopwatch tick:", error);
            finishStopwatch();
        }
    }

    function startStopwatchInterval() {
        stopStopwatchInterval();
        startTime = Date.now();
        stopwatchIntervalId = setInterval(stopwatchTick, 50);
        console.log("Stopwatch interval started with ID:", stopwatchIntervalId);
    }

    function stopStopwatchInterval() {
        if (stopwatchIntervalId !== null) {
            clearInterval(stopwatchIntervalId);
            console.log("Stopwatch interval cleared:", stopwatchIntervalId);
            stopwatchIntervalId = null;
        }
    }

    // MODIFIED: Calculate estimatedDurationMs based on targetMode
    function startStopwatch() {
        // Check if a valid target is set based on the current mode
        const hasValidTarget = (targetMode === 'time' && targetDateTime) || (targetMode === 'duration' && targetDurationMinutes > 0);
        if (stopwatchState !== 'idle' || !hasValidTarget) {
            if (!hasValidTarget) showMessage("Vui l√≤ng ƒë·∫∑t m·ª•c ti√™u h·ª£p l·ªá tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.", 'warning');
            return;
        }

        console.log("Starting stopwatch in mode:", targetMode);
        clearMessage();
        arrivalStatus.textContent = '';
        arrivalStatus.className = '';

        stopwatchStartDate = new Date(); // Record absolute start time
        elapsedTime = 0; // Reset elapsed time for new run
        estimatedDurationMs = 0; // Reset estimated duration
        projectedTargetDateTime = null; // Reset projected end time

        // Calculate estimated duration and projected end time based on mode
        if (targetMode === 'time') {
            estimatedDurationMs = targetDateTime.getTime() - stopwatchStartDate.getTime();
            projectedTargetDateTime = targetDateTime; // Already set
            if (estimatedDurationMs <= 0) {
                showMessage("L·ªói: Th·ªùi gian m·ª•c ti√™u kh√¥ng h·ª£p l·ªá so v·ªõi th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu.", 'error');
                clearTargetState(); // Clear the invalid target
                updateStopwatchUI('idle');
                return;
            }
        } else { // duration mode
            estimatedDurationMs = targetDurationMinutes * 60 * 1000;
            projectedTargetDateTime = new Date(stopwatchStartDate.getTime() + estimatedDurationMs); // Calculate projected end
            if (estimatedDurationMs <= 0) { // Should have been caught by input validation, but double-check
                 showMessage("L·ªói: Th·ªùi l∆∞·ª£ng m·ª•c ti√™u kh√¥ng h·ª£p l·ªá.", 'error');
                 clearTargetState();
                 updateStopwatchUI('idle');
                 return;
            }
             // Update target info to show projected end time as well
             targetInfo.innerHTML = `M·ª•c ti√™u: <span>${targetDurationMinutes} ph√∫t</span> (D·ª± ki·∫øn k·∫øt th√∫c: ${formatTimeHHMMSS(projectedTargetDateTime)})`;
        }

        console.log("Estimated Duration (ms):", estimatedDurationMs, "Projected End:", projectedTargetDateTime);

        updateStopwatchUI('running');
        startStopwatchInterval();
        progressBar.style.width = '0%';
        progressBar.textContent = '0%';
        progressBarContainer.setAttribute('aria-valuenow', '0');
        progressBar.style.backgroundColor = '#5cb85c';
    }

    function pauseStopwatch() {
        if (stopwatchState !== 'running') return;
        console.log("Pausing stopwatch...");
        stopStopwatchInterval();
        const currentRunTime = Date.now() - startTime;
        elapsedTime += currentRunTime;
        startTime = 0;
        updateStopwatchUI('paused');
        stopwatchDisplay.textContent = formatStopwatchTime(elapsedTime);
        updateProgressBar(elapsedTime);
    }

    function resumeStopwatch() {
        if (stopwatchState !== 'paused') return;
        console.log("Resuming stopwatch...");
        updateStopwatchUI('running');
        startStopwatchInterval();
    }

    // MODIFIED: Handle finish logic for both modes
    function finishStopwatch() {
        if (stopwatchState !== 'running' && stopwatchState !== 'paused') return;
        console.log("Finishing stopwatch...");
        const endTimeMs = Date.now();
        stopStopwatchInterval();

        if (stopwatchState === 'running') {
            const currentRunTime = endTimeMs - startTime;
            elapsedTime += currentRunTime;
        }
        startTime = 0;

        stopwatchDisplay.textContent = formatStopwatchTime(elapsedTime);
        updateProgressBar(elapsedTime); // Final progress update

        // --- Validate necessary data ---
        if (!stopwatchStartDate || !estimatedDurationMs || estimatedDurationMs <= 0 || !projectedTargetDateTime) {
             console.error("L·ªói: Thi·∫øu d·ªØ li·ªáu c·∫ßn thi·∫øt (startDate, estimatedDuration, projectedTarget) khi k·∫øt th√∫c.");
             showMessage("L·ªói d·ªØ li·ªáu khi k·∫øt th√∫c b·∫•m gi·ªù.", 'error');
             resetStopwatch(true); // Reset everything on critical error
             return;
        }

        const endTime = new Date(endTimeMs);

        // --- Calculate Arrival/Completion Status ---
        let finalStatusText = '';
        let finalStatusClass = '';
        const differenceMs = projectedTargetDateTime.getTime() - endTime.getTime(); // Positive if finished early/on time

        if (targetMode === 'time') {
            // --- Time Mode Status ---
            const diffMinutes = Math.round(Math.abs(differenceMs) / (1000 * 60));
            const diffSeconds = Math.round(Math.abs(differenceMs) / 1000);
            if (differenceMs > 59999) { // More than 1 min early
                finalStatusText = `‚úÖ ƒê·∫øn s·ªõm ${diffMinutes} ph√∫t!`;
                finalStatusClass = 'early';
            } else if (differenceMs < -59999) { // More than 1 min late
                finalStatusText = `‚ùå ƒê√£ mu·ªôn ${diffMinutes} ph√∫t.`;
                finalStatusClass = 'late';
            } else { // Within +/- 1 min
                finalStatusText = `üëç ƒê·∫øn g·∫ßn ƒë√∫ng gi·ªù! (${differenceMs >= 0 ? '+' : ''}${diffSeconds} gi√¢y)`;
                finalStatusClass = 'on-time';
            }
        } else {
            // --- Duration Mode Status ---
            const timeDiffReadable = formatDurationReadable(Math.abs(differenceMs));
            if (elapsedTime <= estimatedDurationMs) { // Completed within or exactly on time
                 finalStatusText = `‚úÖ Ho√†n th√†nh trong ${formatDurationReadable(elapsedTime)}!`;
                 if (differenceMs > 0) { // Add how much time was saved if any
                     finalStatusText += ` (S·ªõm ${timeDiffReadable})`;
                 }
                 finalStatusClass = 'completed';
            } else { // Exceeded duration
                 finalStatusText = `‚ùå V∆∞·ª£t qu√° m·ª•c ti√™u ${timeDiffReadable}. (T·ªïng: ${formatDurationReadable(elapsedTime)})`;
                 finalStatusClass = 'exceeded';
            }
        }
        arrivalStatus.textContent = finalStatusText;
        arrivalStatus.className = finalStatusClass;

        // --- Prepare History Entry ---
        const startDateStr = stopwatchStartDate.toLocaleDateString('vi-VN');
        const startTimeStr = formatTimeHHMMSS(stopwatchStartDate);
        const endTimeStr = formatTimeHHMMSS(endTime);
        const finalDurationStr = formatStopwatchTime(elapsedTime); // Precise duration
        const durationMinutesStr = formatDurationReadable(elapsedTime); // Readable duration

        const newEntry = {
            id: Date.now(),
            targetMode: targetMode, // Store the mode used
            startDateStr,
            startTimeStr,
            endTimeStr,
            finalDurationStr,
            durationMinutesStr,
            arrivalStatusText: finalStatusText, // Use the calculated status text
            arrivalStatusClass: finalStatusClass, // Use the calculated status class
            // Store specific target info based on mode
            ...(targetMode === 'time' && { targetDateTimeStr: formatTimeHHMMSS(targetDateTime) + ' (' + targetDateTime.toLocaleDateString('vi-VN') + ')' }),
            ...(targetMode === 'duration' && { targetDurationMinutes: targetDurationMinutes, projectedEndTimeStr: formatTimeHHMMSS(projectedTargetDateTime) })
        };

        travelHistory.push(newEntry);
        saveHistory();
        currentPage = 1;
        displayHistory();

        updateStopwatchUI('stopped');
    }

    // MODIFIED: Reset target mode state as well
    function resetStopwatch(clearInputsAndTarget = true) {
        console.log("Resetting stopwatch...");
        stopStopwatchInterval();

        elapsedTime = 0;
        startTime = 0;
        stopwatchStartDate = null;
        // Don't reset estimatedDurationMs or projectedTargetDateTime here, they are set on start

        stopwatchDisplay.textContent = formatStopwatchTime(0);
        // Don't reset progress bar/arrival status here, clearTargetState does it

        if (clearInputsAndTarget) {
            clearTargetState(); // Clear target variables and related UI
            // Reset inputs to default
            setDefaultInputs();
            // Reset mode selector to 'time' (or load from preference if needed)
            // Let's stick to resetting to 'time' for simplicity on full reset
            targetMode = 'time';
            targetModeTimeRadio.checked = true;
            handleTargetModeChange(); // Update visible inputs based on reset mode
        } else {
             // If not clearing inputs, just clear arrival status and progress from previous run
             arrivalStatus.textContent = '';
             arrivalStatus.className = '';
             progressBar.style.width = '0%';
             progressBar.textContent = '';
             progressBarContainer.setAttribute('aria-valuenow', '0');
             progressBar.style.backgroundColor = '#5cb85c';
        }

        updateStopwatchUI('idle'); // Set UI to initial idle state (will enable/disable Start based on target)
    }

    // === History Logic ===
    // MODIFIED: Display history based on targetMode stored in entry
    function displayHistory() {
        try {
            travelHistoryList.innerHTML = '';
            const noHistoryMsgElement = travelHistoryList.querySelector('.no-history-message');
            if (noHistoryMsgElement) noHistoryMsgElement.remove();

            clearHistoryBtn.disabled = travelHistory.length === 0;

            if (travelHistory.length === 0) {
                pageInfo.textContent = 'Kh√¥ng c√≥ l·ªãch s·ª≠';
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
                travelHistoryList.innerHTML = '<li class="no-history-message">Kh√¥ng c√≥ l·ªãch s·ª≠ n√†o ƒë∆∞·ª£c ghi l·∫°i.</li>';
                return;
            }

            const totalItems = travelHistory.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage > totalPages) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const itemsToShow = travelHistory.slice().reverse().slice(startIndex, endIndex);

            console.log(`Displaying history page ${currentPage}/${totalPages}, items ${startIndex}-${endIndex - 1}`);

            itemsToShow.forEach(entry => {
                const li = document.createElement('li');
                li.className = 'history-entry';

                // Determine target display string based on mode in history
                let targetDisplay = 'N/A';
                if (entry.targetMode === 'time' && entry.targetDateTimeStr) {
                    targetDisplay = entry.targetDateTimeStr;
                } else if (entry.targetMode === 'duration' && entry.targetDurationMinutes) {
                    targetDisplay = `${entry.targetDurationMinutes} ph√∫t`;
                    // Optionally add projected end time if stored
                    // if (entry.projectedEndTimeStr) {
                    //    targetDisplay += ` (D·ª± ki·∫øn: ${entry.projectedEndTimeStr})`;
                    // }
                }

                // Use status text and class directly from history entry
                const statusHTML = entry.arrivalStatusText
                    ? `<div class="history-status ${entry.arrivalStatusClass || ''}">${entry.arrivalStatusText}</div>`
                    : '';

                li.innerHTML = `
                    <div class="history-row">
                        <div class="history-group"><strong class="history-label">B·∫Øt ƒë·∫ßu:</strong> <span class="history-value">${entry.startTimeStr || 'N/A'} (${entry.startDateStr || 'N/A'})</span></div>
                        <div class="history-group"><strong class="history-label">K·∫øt th√∫c:</strong> <span class="history-value">${entry.endTimeStr || 'N/A'}</span></div>
                    </div>
                    <div class="history-row">
                          <div class="history-group"><strong class="history-label">M·ª•c ti√™u:</strong> <span class="history-value">${targetDisplay}</span></div>
                    </div>
                    <div class="history-row">
                        <div class="history-group"><strong class="history-label">Th·ªùi gian:</strong> <span class="history-value">${entry.finalDurationStr || 'N/A'}</span> <span class="history-value-alt">(${entry.durationMinutesStr || 'N/A'})</span></div>
                    </div>
                    ${statusHTML}
                `;
                travelHistoryList.appendChild(li);
            });

            pageInfo.textContent = `Trang ${currentPage} / ${totalPages}`;
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;

        } catch (error) {
            console.error("Error displaying history:", error);
            travelHistoryList.innerHTML = '<li style="color: red; text-align: center;">L·ªói hi·ªÉn th·ªã l·ªãch s·ª≠</li>';
            showMessage("Kh√¥ng th·ªÉ hi·ªÉn th·ªã l·ªãch s·ª≠.", 'error');
        }
    }


    function loadHistory() {
        try {
            const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
            travelHistory = saved ? JSON.parse(saved) : [];
            currentPage = 1;
            displayHistory();
            console.log(`Loaded ${travelHistory.length} history entries.`);
        } catch (error) {
            console.error("Error loading history:", error);
            showMessage("L·ªói khi t·∫£i l·ªãch s·ª≠ t·ª´ b·ªô nh·ªõ.", 'error');
            travelHistory = [];
            localStorage.removeItem(HISTORY_STORAGE_KEY);
            displayHistory();
        }
    }

    function saveHistory() {
        try {
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(travelHistory));
        } catch (error) {
            console.error("Error saving history:", error);
            showMessage("Kh√¥ng th·ªÉ l∆∞u l·ªãch s·ª≠.", 'error');
        }
    }

    function clearTravelHistory() {
        if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a TO√ÄN B·ªò l·ªãch s·ª≠ kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.")) {
            travelHistory = [];
            saveHistory();
            currentPage = 1;
            displayHistory();
            showMessage("ƒê√£ x√≥a to√†n b·ªô l·ªãch s·ª≠.", 'success');
        }
    }

    // === Wake Lock Logic === (No changes needed here)
    async function toggleWakeLock() {
        if (!('wakeLock' in navigator)) {
            showMessage('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng gi·ªØ m√†n h√¨nh s√°ng.', 'warning');
            return;
        }
        try {
            if (wakeLock) {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake Lock released.');
                wakeLockBtn.classList.remove('active');
                wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng';
                showMessage('ƒê√£ t·∫Øt ch·∫ø ƒë·ªô gi·ªØ m√†n h√¨nh s√°ng.', 'info');
            } else {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock was released automatically.');
                    wakeLock = null;
                    wakeLockBtn.classList.remove('active');
                    wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng';
                });
                console.log('Wake Lock active.');
                wakeLockBtn.classList.add('active');
                wakeLockBtn.title = 'ƒêang gi·ªØ m√†n h√¨nh s√°ng (Nh·∫•n ƒë·ªÉ t·∫Øt)';
                showMessage('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô gi·ªØ m√†n h√¨nh s√°ng.', 'success');
            }
        } catch (err) {
            console.error(`Wake Lock Error: ${err.name}, ${err.message}`);
            wakeLock = null;
            wakeLockBtn.classList.remove('active');
            wakeLockBtn.title = 'Gi·ªØ m√†n h√¨nh s√°ng (L·ªói)';
            showMessage(`L·ªói Wake Lock: ${err.message}`, 'error');
        }
    }

    async function handleVisibilityChange() {
        if (wakeLock !== null && document.visibilityState === 'visible') {
            try {
                await toggleWakeLock(); // Release old
                await toggleWakeLock(); // Request new
                console.log('Wake Lock re-acquired on visibility change.');
            } catch (err) {
                console.error('Failed to re-acquire Wake Lock:', err);
                showMessage('Kh√¥ng th·ªÉ t·ª± ƒë·ªông b·∫≠t l·∫°i ch·∫ø ƒë·ªô gi·ªØ s√°ng.', 'warning');
            }
        }
    }

    // === Initialization ===
    function setDefaultInputs() {
        targetDateInput.value = formatDateYYYYMMDD(new Date());
        targetTimeInput.value = "06:55";
        targetDurationInput.value = ''; // Clear duration input initially
    }

    // MODIFIED: Load target mode preference as well
    function loadPreferences() {
        // Load format preference
        const savedFormat = localStorage.getItem(FORMAT_STORAGE_KEY);
        if (savedFormat === '24') {
            is24HourFormat = true;
            formatToggleButton.textContent = '12h';
        } else {
            is24HourFormat = false;
            formatToggleButton.textContent = '24h';
        }
        updateClock();

        // Load target mode preference
        const savedMode = localStorage.getItem(TARGET_MODE_STORAGE_KEY);
        if (savedMode === 'duration') {
            targetMode = 'duration';
            targetModeDurationRadio.checked = true;
        } else {
            targetMode = 'time'; // Default to time
            targetModeTimeRadio.checked = true;
        }
        // Don't call handleTargetModeChange here yet, wait for DOM ready
    }

    // MODIFIED: Save target mode preference
    function savePreferences() {
        localStorage.setItem(FORMAT_STORAGE_KEY, is24HourFormat ? '24' : '12');
        localStorage.setItem(TARGET_MODE_STORAGE_KEY, targetMode); // Save current target mode
    }


    function initializeApp() {
        console.log("Initializing App (v4 - Duration Target)...");
        try {
            // Clear any stray intervals
            if (mainClockIntervalId) clearInterval(mainClockIntervalId);
            if (stopwatchIntervalId) clearInterval(stopwatchIntervalId);
            mainClockIntervalId = null;
            stopwatchIntervalId = null;

            // Start Main Clock
            mainClockIntervalId = setInterval(updateClock, 1000);
            loadPreferences(); // Loads format AND target mode state
            updateClock(); // Initial clock display based on loaded format
            console.log("Main clock interval started with ID:", mainClockIntervalId);

            // Set Default Input Values
            setDefaultInputs();

            // Apply loaded target mode to UI *after* DOM is ready
            handleTargetModeChange();

            // --- Event Listeners ---
            formatToggleButton.addEventListener('click', () => {
                is24HourFormat = !is24HourFormat;
                formatToggleButton.textContent = is24HourFormat ? '12h' : '24h';
                savePreferences();
                updateClock();
            });

            // Target Mode Radio Buttons Listener
            targetModeTimeRadio.addEventListener('change', handleTargetModeChange);
            targetModeDurationRadio.addEventListener('change', handleTargetModeChange);

            // Target Setting Buttons Listener (using the common function)
            setTargetBtn.addEventListener('click', setTarget);
            setDurationTargetBtn.addEventListener('click', setTarget); // Both buttons call the same function

            // Stopwatch Controls
            startBtn.addEventListener('click', startStopwatch);
            pauseBtn.addEventListener('click', pauseStopwatch);
            resumeBtn.addEventListener('click', resumeStopwatch);
            stopBtn.addEventListener('click', finishStopwatch);
            resetBtn.addEventListener('click', () => resetStopwatch(true));
            clearHistoryBtn.addEventListener('click', clearTravelHistory);

            // Pagination
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) { currentPage--; displayHistory(); }
            });
            nextPageBtn.addEventListener('click', () => {
                const totalPages = Math.ceil(travelHistory.length / itemsPerPage);
                if (currentPage < totalPages) { currentPage++; displayHistory(); }
            });

            // Wake Lock
            if (!('wakeLock' in navigator)) {
                wakeLockBtn.disabled = true;
                wakeLockBtn.title = 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng n√†y';
            } else {
                wakeLockBtn.addEventListener('click', toggleWakeLock);
                document.addEventListener('visibilitychange', handleVisibilityChange);
            }

            // --- Load History & Set Initial UI State ---
            loadHistory();
            // Initial reset without clearing defaults, applies loaded target mode
            resetStopwatch(false);
            // updateStopwatchUI('idle'); // Called inside resetStopwatch

            console.log("App Initialized Successfully.");

        } catch (error) {
            console.error("Error during app initialization:", error);
            showMessage("ƒê√£ x·∫£y ra l·ªói nghi√™m tr·ªçng khi kh·ªüi t·∫°o ·ª©ng d·ª•ng. Vui l√≤ng th·ª≠ t·∫£i l·∫°i trang.", 'error', 0);
        }
    }

    // --- Run Initialization ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }

</script>

</body>
</html>
